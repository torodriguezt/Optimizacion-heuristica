[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Portafolio trabajos",
    "section": "",
    "text": "Primer trabajo: Optimización heurística\n\n\n\n\n\n\noptimización\n\n\nalgoritmos genéticos\n\n\ncolonia de hormigas\n\n\nwebscrapping\n\n\n\n\n\n\n\n\n\nNov 15, 2024\n\n\nCatalina Restrepo Salgado, Julián Castaño Pineda, Tomás Rodríguez Taborda, Luis Andrés Altamar Romero\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome To My Blog\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\nNov 12, 2024\n\n\nTristan O’Malley\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Primer trabajo: Optimización heurística",
    "section": "",
    "text": "Code\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "posts/post-with-code/index.html#considere-las-siguientes-funciones-de-prueba",
    "href": "posts/post-with-code/index.html#considere-las-siguientes-funciones-de-prueba",
    "title": "Primer trabajo: Optimización heurística",
    "section": "",
    "text": "Función de Rosenbrock \\[ f(x, y) = (a - x)^2 + b(y - x^2)^2 \\]\nFunción de Rastrigin \\[ f(\\mathbf{x}) = An + \\sum_{i=1}^{n} \\left[ x_i^2 - A \\cos(2 \\pi x_i) \\right] \\]\nFunción de Schwefel \\[ f(\\mathbf{x}) = 418.9829n - \\sum_{i=1}^{n} x_i \\sin(\\sqrt{|x_i|}) \\]\nFunción de Griewank \\[ f(\\mathbf{x}) = 1 + \\frac{1}{4000} \\sum_{i=1}^{n} x_i^2 - \\prod_{i=1}^{n} \\cos\\left(\\frac{x_i}{\\sqrt{i}}\\right) \\]\nFunción Goldstein-Price \\[ f(x, y) = \\left[1 + (x + y + 1)^2 (19 - 14x + 3x^2 - 14y + 6xy + 3y^2)\\right] \\left[30 + (2x - 3y)^2 (18 - 32x + 12x^2 + 48y - 36xy + 27y^2)\\right] \\]\nFunción de las seis jorobas de camello \\[ f(x, y) = \\left(4 - 2.1x^2 + \\frac{x^4}{3}\\right)x^2 + xy + \\left(-4 + 4y^2\\right)y^2 \\]\n\n\n\n\nEscoja dos funciones de prueba.\nOptimización con método de descenso por gradiente:\n\nOptimice las funciones seleccionadas en dos y tres dimensiones usando un método de descenso por gradiente con condición inicial aleatoria.\n\nOptimización con métodos heurísticos:\n\nOptimice las funciones seleccionadas en dos y tres dimensiones usando:\n\nAlgoritmos evolutivos.\nOptimización de partículas.\nEvolución diferencial.\n\n\nRepresentación visual:\n\nCree un GIF animado o un video que muestre el proceso de optimización usando:\n\nDescenso por gradiente.\nMétodos heurísticos.\n\n\n\n\n\n\nReflexione sobre los siguientes puntos: - ¿Qué aportaron los métodos de descenso por gradiente y qué aportaron los métodos heurísticos? - Para responder a esta pregunta, considere: - El valor final de la función objetivo. - El número de evaluaciones de la función objetivo. - Es posible que se requiera realizar varias corridas de los algoritmos para obtener conclusiones significativas."
  },
  {
    "objectID": "posts/post-with-code/index.html#problema-del-viajero",
    "href": "posts/post-with-code/index.html#problema-del-viajero",
    "title": "Primer trabajo: Optimización heurística",
    "section": "Problema del Viajero:",
    "text": "Problema del Viajero:\nUn vendedor debe realizar un recorrido por todas las capitales de los 32 estados de los Estados Unidos Mexicanos.\n\nTareas:\n\nOptimización con métodos metaheurísticos:\n\nUtilice colonias de hormigas para encontrar el orden óptimo del recorrido.\nUtilice algoritmos genéticos para encontrar el orden óptimo del recorrido.\n\nCosto del recorrido:\n\nEl costo de desplazamiento entre ciudades se calcula como la suma de:\n\nEl valor de la hora del vendedor (este es un parámetro que debe estudiarse).\nEl costo de los peajes.\nEl costo del combustible.\n\nCada equipo debe definir el vehículo que utilizará el vendedor para realizar el recorrido y, con base en esta elección, calcular el costo del combustible.\n\n\n\n\nRepresentación Visual:\n\nCree un GIF animado o un video que muestre cómo se comporta la mejor solución encontrada, usando un gráfico del recorrido en el mapa de México.\n\n\n\n\nDiscusión:\nReflexione sobre: - Los resultados obtenidos con las colonias de hormigas y los algoritmos genéticos. - Comparación de costos y tiempo de ejecución.\n\n\nSolución:\n\nExtracción datos:\nPara empezar a solucionar el problema, es necesario obtener información sobre el valor del salario del vendedor, el costo de los peajes, y definir el modelo del automóvil junto con su respectivo gasto de gasolina, para calcular el gasto total destinado al combustible. En todo el proceso de extracción de la información se tomaron las capitales de cada estado como la ciudad de referencia para obtener la información.\n\nDistancias y tiempo de conducción\nPodemos obtener la tabla de distancias y tiempo de conducción entre las ciudades, de manera sencilla utilizando el siguiente sitio web. Dicho sitio web nos permite obtener la tabla de distancias y la tabla de tiempo de conducción entre las ciudades ingresando el nombre de cada una de ellas.\n\n\nPeajes\nPara obtener la información de los peajes, utilizamos la siguiente página, que contiene datos sobre el costo de los peajes para desplazarse entre dos ciudades.\nDebido al gran número de combinaciones posibles, programamos un bot en Selenium que realiza web scraping en dicho sitio, lo que nos permitió automatizar la extracción de la información. A continuación, se muestra el código utilizado para programar el bot.\n\n\nCode\ndriver = webdriver.Chrome()\n\n# Navegar a la página web\ndriver.get('https://app.sct.gob.mx/sibuac_internet/ControllerUI?action=cmdEscogeRuta')\n\n# Diccionario con estados y sus capitales\nestados_capitales = {\n    'Aguascalientes': 'Aguascalientes',\n    'Baja California': 'Mexicali',\n    'Baja California Sur': 'La Paz',\n    'Campeche': 'Campeche',\n    'Coahuila': 'Saltillo',\n    'Colima': 'Colima',\n    'Chiapas': 'Tuxtla Gutiérrez',\n    'Chihuahua': 'Chihuahua',\n    'Distrito Federal': 'Cd. De México (Zócalo)',\n    'Durango': 'Durango',\n    'Guanajuato': 'Guanajuato',\n    'Guerrero': 'Chilpancingo',\n    'Hidalgo': 'Pachuca',\n    'Jalisco': 'Guadalajara',\n    'México': 'Toluca',\n    'Michoacán': 'Morelia',\n    'Morelos': 'Cuernavaca',\n    'Nayarit': 'Tepic',\n    'Nuevo León': 'Monterrey',\n    'Oaxaca': 'Oaxaca',\n    'Puebla': 'Puebla',\n    'Querétaro': 'Querétaro',\n    'Quintana Roo': 'Chetumal',\n    'San Luis Potosí': 'San Luis Potosí',\n    'Sinaloa': 'Culiacán',\n    'Sonora': 'Hermosillo',\n    'Tabasco': 'Villahermosa',\n    'Tamaulipas': 'Cd. Victoria',\n    'Tlaxcala': 'Tlaxcala',\n    'Veracruz': 'Xalapa',\n    'Yucatán': 'Mérida',\n    'Zacatecas': 'Zacatecas'\n}\n\n\n\nestados = list(estados_capitales.keys())\nmatriz_resultados = pd.DataFrame(index=estados, columns=estados)\n\nfor estado_origen in estados:\n    for estado_destino in estados:\n        if estado_origen == estado_destino:\n            continue\n\n        try:\n            select_element_origen = WebDriverWait(driver, 10).until(\n                EC.presence_of_element_located((By.NAME, 'edoOrigen'))\n            )\n            select_origen = Select(select_element_origen)\n            select_origen.select_by_visible_text(estado_origen)\n            time.sleep(2)  \n\n            capital_origen = estados_capitales[estado_origen]\n            select_element_ciudad_origen = WebDriverWait(driver, 10).until(\n                EC.presence_of_element_located((By.NAME, 'ciudadOrigen'))\n            )\n            select_ciudad_origen = Select(select_element_ciudad_origen)\n            select_ciudad_origen.select_by_visible_text(capital_origen)\n\n            select_element_destino = WebDriverWait(driver, 10).until(\n                EC.presence_of_element_located((By.NAME, 'edoDestino'))\n            )\n            select_destino = Select(select_element_destino)\n            select_destino.select_by_visible_text(estado_destino)\n            time.sleep(2)  \n\n            capital_destino = estados_capitales[estado_destino]\n            select_element_ciudad_destino = WebDriverWait(driver, 10).until(\n                EC.presence_of_element_located((By.NAME, 'ciudadDestino'))\n            )\n            select_ciudad_destino = Select(select_element_ciudad_destino)\n            select_ciudad_destino.select_by_visible_text(capital_destino)\n\n            boton_consultar = WebDriverWait(driver, 10).until(\n                EC.element_to_be_clickable((By.NAME, 'cmdEnviar'))\n            )\n            boton_consultar.click()\n            time.sleep(3)\n\n            resultado_element = WebDriverWait(driver, 10).until(\n                EC.presence_of_element_located((By.XPATH, '(//tr[@class=\"tr_gris\"])[last()]/td[@align=\"right\"][last()]'))\n            )\n            resultado_texto = resultado_element.text.strip()  # .strip() elimina espacios adicionales\n            matriz_resultados.at[estado_origen, estado_destino] = resultado_texto\n            print(f\"De {estado_origen} a {estado_destino}: {resultado_texto}\")\n\n        except Exception as e:\n            print(f\"No se pudo extraer el valor para {estado_origen} a {estado_destino}: {e}\")\n            matriz_resultados.at[estado_origen, estado_destino] = None\n\n        driver.get('https://app.sct.gob.mx/sibuac_internet/ControllerUI?action=cmdEscogeRuta')\n        time.sleep(3)  \n\nprint(matriz_resultados)\n\ndriver.quit()\n\n\n\n\n\nDefinición gastos:\nEn la siguiente sección definimos los gastos que se deben de consultar, como el salario del vendedor, el modelo del carro y su gasto de combustible.\n\nSalario del vendedor\nPara definir el salario del vendedor, tomaremos como referencia el salario minimo en México, el cual actualmente se encuentra 248,93 pesos diarios, por lo cual, para una jornada de 8 horas, el salario mínimo por hora es de 31,11625, por lo cual definiremos el salario en 35 pesos mexicanos por hora.\n\n\nModelo del carro y gasto en gasolina\nEl modelo de carro que definiremos es un Nissan Versa debido a ser el modelo de carro más vendido actualmente en México, con lo cual permitirá hacer una estimación más justa del costo total de realizar la ruta por los 32 estados mexicanos en el contexto de dicho país.\nEn carreteras el rendimiento promedio de este modelo por galón es de 64 kilómetros, además el tipo de gasolina que utiliza, en México se suele llamar “Gasolina Magna” la cual a día del 14 de Noviembre tiene un precio promedio de 23.96 pesos mexicanos por galón.\n\n\n\nTransformaciones\nCon la información anterior debemos calcular el costo de desplazamiento entre las ciudades, sin embargo, se observa como no toda la información se encuentra en pesos mexicanos, hay información en galones, otra en horas, otra en kilómetros, etc. Por lo cual vamos a realizar las siguientes transformaciones en las unidades para poder sumar toda la información como gasto en pesos mexicanos. Notemos que para el caso de los peajes ya estos estan en pesos mexicanos por lo que no necesitamos cambiar las unidades.\n\nTiempo de viaje\nEl costo por el salario del vendedor es calculado como:\n$$ \\text{Costo vendedor} = \\text{tiempo} \\times \\text{salario del vendedor} $$\n\n\nGasolina para el viaje\nEl gasto total en gasolina lo calculamos como:\n$$ \\text{Costo gasolina} = \\left( \\frac{\\text{Distancia}}{\\text{Rendimiento (km/galón)}} \\right) \\times \\text{Precio por galón} $$\n\n\n\nGasto total\nCon todo lo realizado anteriormente ya contamos con la información que necesitamos y en las unidades requeridas para sumar todo como pesos mexicanos.\n\\[\n\\text{Gasto recorrido} = \\text{Costo gasolina} + \\text{Costo vendedor} + \\text{Costo Peajes}\n\\]\n\n\nRuta óptima\nAhora con todo en las mismas unidades podemos pasar a utilizar los algortimos de colonia de hormigas y algoritmos genéticos para encontrar la ruta óptima del vendedor a través de los 32 estados de México.\n\nColonia de Hormigas\nLos algoritmos de colonia de hormigas (Ant Colony Optimization, ACO) son una técnica de optimización basada en la inteligencia colectiva observada en las colonias de hormigas naturales. Se inspiraron en el comportamiento de las hormigas en la naturaleza para resolver problemas complejos de optimización combinatoria. Los hiperparámetros del modelo son los siguientes:\n\nCantidad de hormigas: Cantidad de hormigas que participarán en cada iteración de la búsqueda de soluciones. Influye en la capacidad del algoritmo de explorar diferentes soluciones de manera simultánea. En nuestro caso utilizaremos 32 hormigas, es decir, igual al número de estados en México.\nAlpha: Controla la influencia de la feromona en la probabilidad de que una hormiga elija ese camino. A medida que el valor aumenta, las hormigas son más propensas a seguir caminos con más feromona. Utilizamos un valor de 1 para una influencia moderada de las feromonas depositadas.\nBeta: Controla la preferencia de las hormigas por caminos más “baratos” o prometedores, lo cual ayuda aumentar la exploración. Utilizamos un valor de 2 ya que buscamos minimizar el costo del viaje.\n\\(\\rho\\): Indica la tasa de evaporación de la feromona, lo cual evita que las soluciones previas influencien las iteraciones futuras. Seleccionamos una tasa de evaporación del 0.5, es decir, el 50% de las feromonas se evaporan en cada iteración.\n\\(Q\\): Cantidad de feromona depositada por una hormiga en su recorrido tras encontrar una solución. Utilizamos un valor de 100 para indicar la cantidad de feromonas en el camino.\n\nCon los hiperparámetros definidos, podemos pasar a ejecutar el algoritmo de colonia de hormigas. La solución encontrada se puede observar en la Figura\n\n\nAlgoritmo genético\nLos algoritmos genéticos (Genetic Algorithms, GA) son una técnica de optimización inspirada en los principios de la selección natural y la evolución biológica. Los GA buscan soluciones óptimas mediante la creación, evaluación y modificación de una población de individuos, representando posibles soluciones a un problema dado. La evolución de la población se realiza mediante operadores genéticos como la mutación. Los hiperparámetros clave del modelo son los siguientes:\n\nTamaño de la población: Define el número de individuos en cada generación. Un tamaño de población más grande permite una mejor exploración del espacio de soluciones, pero también aumenta el tiempo de cómputo. En nuestro caso, utilizamos una población de 100 individuos, lo que proporciona un equilibrio adecuado entre diversidad y eficiencia computacional.\nNúmero de generaciones: Especifica cuántas veces se evolucionará la población mediante el proceso de selección, cruce y mutación. Utilizamos 200 generaciones para permitir al algoritmo explorar el espacio de búsqueda y converger hacia una solución óptima o cercana al óptimo.\nTasa de mutación: Representa la probabilidad de que un gen sea modificado aleatoriamente en un individuo. La mutación introduce variación genética, lo que ayuda a explorar nuevas áreas del espacio de búsqueda y a evitar estancamientos en óptimos locales. Utilizamos una tasa de mutación de 0.1 (10%), lo que mantiene una buena cantidad de diversidad sin perturbar excesivamente a la población."
  },
  {
    "objectID": "posts/post-with-code/index.html#funciones-a-optimizar",
    "href": "posts/post-with-code/index.html#funciones-a-optimizar",
    "title": "Primer trabajo: Optimización heurística",
    "section": "Funciones a optimizar",
    "text": "Funciones a optimizar\n\nFunción de RosenbrockFunción de RastriginFunción de SchwefelFunción de GriewankFunción Goldstein-PriceFunción de las seis jorobas de camello\n\n\n\\[f(\\mathbf{x}) = \\sum_{i=1}^{d-1} \\left[ 100(x_{i+1} - x_i^2)^2 + (x_i - 1)^2 \\right]\\]\nEn 2 dimensiones se puede definir como \\[ f(x_1, x_2) = (a - x_1)^2 + b(x_2 - x_1^2)^2 \\]\nLa Función de Rosenbrock, también conocida como función del valle o del plátano, es ampliamente utilizada para evaluar algoritmos de optimización basados en gradientes. Esta función es unimodal y presenta su mínimo global en un valle parabólico estrecho, lo que facilita su localización. Sin embargo, segun @simonfraser_rosenbrock citando a @picheny2012benchmark convergencia hacia este mínimo puede ser desafiante debido a la naturaleza del valle.\nLa función se evalúa generalmente en el hipercubo \\(x_i \\in [-5, 10]\\) y tiene un mínimo global en \\(f(1,...,1) = 0\\)\n\n\n\\[f(\\mathbf{x}) = 10d + \\sum_{i=1}^{d} \\left[ x_i^2 - 10 \\cos(2\\pi x_i) \\right]\\]\nSegun @simonfraser_rosenbroc, la función de Rastrigin tiene varios mínimos locales. Es altamente multimodal, pero las ubicaciones de los mínimos se distribuyen regularmente. La función generalmente se evalúa en el hipercubo \\(x_i \\in [-5.12, 5.12]\\) y su mínimo local se encuentra en \\(f(0,...,0)=0\\).\n\n\n\\[ f(\\mathbf{x}) = 418.9829d - \\sum_{i=1}^{d} x_i \\sin(\\sqrt{|x_i|}) \\]\nSegun @simonfraser_rosenbrock La función de Schwefel es compleja, con muchos mínimos locales. Normalmente se evalua en el hipercubo $x_i [-500,500] $. Su minimo global está en \\(f(420.9687,...,420.9687)=0\\)\n\n\n\\[ f(\\mathbf{x}) = 1 + \\frac{1}{4000} \\sum_{i=1}^{d} x_i^2 - \\prod_{i=1}^{d} \\cos\\left(\\frac{x_i}{\\sqrt{i}}\\right) \\]\nSegun @simonfraser_rosenbrock la función de Griewank tiene muchos mínimos locales generalizados, que se distribuyen de forma regular. Lo que hace compleja su optimización al minimo global. Normalmente se evalua en el hipercubo $x_i [-600,600] $. Su minimo global está en \\(f(0,...,0)=0\\)\n\n\n\\[\n\\begin{align}\nf(x_1, x_2) = & \\left[1 + (x_1 + x_2 + 1)^2 (19 - 14x_1 + 3x_1^2 - 14x_2 + 6x_1x_2 + 3x_2^2)\\right] \\\\\n         & \\left[30 + (2x_1 - 3x_2)^2 (18 - 32x_1 + 12x_1^2 + 48x_2 - 36x_1x_2 + 27x_2^2)\\right]\n\\end{align}\n\\]\nLa función Goldstein-Price es una función en 2 dimensiones y tiene varios mínimos locales. Segun @molga2005test, la función generalmente se evalúa en el cuadrado \\(x_1 \\in [-2, 2]\\) y \\(x_1 \\in [-2, 2]\\) . Su mínimo global es \\(f(0,-1) = 3\\)\n\n\n\\[ f(x_1, x_2) = \\left(4 - 2.1x_1^2 + \\frac{x_1^4}{3}\\right)x_1^2 + x_1x_2 + \\left(-4 + 4x_2^2\\right)x_2^2 \\]\nLa función de las seis jorobas de camello es una función en 2 dimensiones.Segun @molga2005test la función tiene seis mínimos locales, dos de los cuales son globales y recomienda evaluar la función en el rectángulo \\(x_1 \\in [-3, 3], x_2 \\in [-2, 2]\\), donde los mínimos globales son \\(f(0.0898,-0.7126) = -1.0316\\) y \\(f(-0.0898, 0.7126) = -1.0316\\)"
  },
  {
    "objectID": "posts/post-with-code/index.html#proceso-de-optimización",
    "href": "posts/post-with-code/index.html#proceso-de-optimización",
    "title": "Primer trabajo: Optimización heurística",
    "section": "Proceso de optimización",
    "text": "Proceso de optimización\n\nOptimización por descenso del gradiente\n\nFunción de RosenbrockFunción de SchwefelFunción de GriewankFunción Goldstein-PriceFunción de las seis jorobas de camello\n\n\n\\[ f(x_1, x_2) = (a - x_1)^2 + b(x_2 - x_1^2)^2 \\]\n\n\n\\[ f(x_1,x_2) = 418.9829n - \\sum_{i=1}^{2} x_i \\sin(\\sqrt{|x_i|}) \\]\n\n\n\\[ f(x_1,x_2) = 1 + \\frac{1}{4000} \\sum_{i=1}^{2} x_i^2 - \\prod_{i=1}^{2} \\cos\\left(\\frac{x_i}{\\sqrt{i}}\\right) \\]\n\n\n\\[\n\\begin{align}\nf(x_1, x_2) = & \\left[1 + (x_1 + x_2 + 1)^2 (19 - 14x_1 + 3x_1^2 - 14x_2 + 6x_1x_2 + 3x_2^2)\\right] \\\\\n         & \\left[30 + (2x_1 - 3x_2)^2 (18 - 32x_1 + 12x_1^2 + 48x_2 - 36x_1x_2 + 27x_2^2)\\right]\n\\end{align}\n\\]\n\n\n\\[ f(x_1, x_2) = \\left(4 - 2.1x_1^2 + \\frac{x_1^4}{3}\\right)x_1^2 + x_1x_2 + \\left(-4 + 4x_2^2\\right)x_2^2 \\]\n\n\n\n\n\nTareas:\n\nEscoja dos funciones de prueba.\nOptimización con método de descenso por gradiente:\n\nOptimice las funciones seleccionadas en dos y tres dimensiones usando un método de descenso por gradiente con condición inicial aleatoria.\n\nOptimización con métodos heurísticos:\n\nOptimice las funciones seleccionadas en dos y tres dimensiones usando:\n\nAlgoritmos evolutivos.\nOptimización de partículas.\nEvolución diferencial.\n\n\nRepresentación visual:\n\nCree un GIF animado o un video que muestre el proceso de optimización usando:\n\nDescenso por gradiente.\nMétodos heurísticos.\n\n\n\n\n\nDiscusión:\nReflexione sobre los siguientes puntos: - ¿Qué aportaron los métodos de descenso por gradiente y qué aportaron los métodos heurísticos? - Para responder a esta pregunta, considere: - El valor final de la función objetivo. - El número de evaluaciones de la función objetivo. - Es posible que se requiera realizar varias corridas de los algoritmos para obtener conclusiones significativas."
  },
  {
    "objectID": "posts/post-with-code/funciones.html",
    "href": "posts/post-with-code/funciones.html",
    "title": "",
    "section": "",
    "text": "CodeShow All CodeHide All Code\n\n\n\n\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n\n\nMatplotlib is building the font cache; this may take a moment.\n\n\n\n\nCode\nimport numpy as np\n\n# Función de Rosenbrock\ndef rosenbrock(x1, x2, a=1, b=100):\n    return (a - x1)**2 + b * (x2 - x1**2)**2\n\n# Función de Schwefel\ndef schwefel(x1, x2):\n    return 418.9829 * 2 - (x1 * np.sin(np.sqrt(np.abs(x1))) + x2 * np.sin(np.sqrt(np.abs(x2))))\n\n# Función de Griewank\ndef griewank(x1, x2):\n    return 1 + (x1**2 + x2**2) / 4000 - (np.cos(x1 / np.sqrt(1)) * np.cos(x2 / np.sqrt(2)))\n\n# Función Goldstein-Price\ndef goldstein_price(x1, x2):\n    term1 = 1 + (x1 + x2 + 1)**2 * (19 - 14*x1 + 3*x1**2 - 14*x2 + 6*x1*x2 + 3*x2**2)\n    term2 = 30 + (2*x1 - 3*x2)**2 * (18 - 32*x1 + 12*x1**2 + 48*x2 - 36*x1*x2 + 27*x2**2)\n    return term1 * term2\n\n# Función de las seis jorobas de camello\ndef six_hump_camel(x1, x2):\n    return (4 - 2.1*x1**2 + (x1**4) / 3) * x1**2 + x1 * x2 + (-4 + 4*x2**2) * x2**2\n\n\n\n\nCode\ndef plot_function(f, x1_range, x2_range, title=\"Function Plot\"):\n    x1 = np.linspace(x1_range[0], x1_range[1], 400)\n    x2 = np.linspace(x2_range[0], x2_range[1], 400)\n    X1, X2 = np.meshgrid(x1, x2)\n    Z = f(X1, X2)\n\n    fig = plt.figure(figsize=(14, 6))\n\n    # 3D plot\n    ax1 = fig.add_subplot(121, projection='3d')\n    ax1.plot_surface(X1, X2, Z)\n    ax1.set_title(f'3D Plot of {title}')\n    ax1.set_xlabel('X1')\n    ax1.set_ylabel('X2')\n    ax1.set_zlabel('Z')\n\n    # Contour plot\n    ax2 = fig.add_subplot(122)\n    contour = ax2.contour(X1, X2, Z)\n    ax2.set_title(f'Contour Plot of {title}')\n    ax2.set_xlabel('X1')\n    ax2.set_ylabel('X2')\n    fig.colorbar(contour, ax=ax2)\n\n    plt.show()\n\ndef plot_function(f, x1_range, x2_range, title=\"Function Plot\", x1_point=None, x2_point=None):\n    x1 = np.linspace(x1_range[0], x1_range[1], 400)\n    x2 = np.linspace(x2_range[0], x2_range[1], 400)\n    X1, X2 = np.meshgrid(x1, x2)\n    Z = f(X1, X2)\n\n    fig = plt.figure(figsize=(14, 6))\n\n    # 3D plot\n    ax1 = fig.add_subplot(121, projection='3d')\n    ax1.plot_surface(X1, X2, Z)\n    ax1.set_title(f'3D Plot of {title}')\n    ax1.set_xlabel('X1')\n    ax1.set_ylabel('X2')\n    ax1.set_zlabel('Z')\n\n    if x1_point is not None and x2_point is not None:\n        z_point = f(x1_point, x2_point)\n        ax1.scatter(x1_point, x2_point, z_point+1, color='red', s=50)\n\n    # Contour plot\n    ax2 = fig.add_subplot(122)\n    contour = ax2.contour(X1, X2, Z, cmap='viridis')\n    ax2.set_title(f'Contour Plot of {title}')\n    ax2.set_xlabel('X1')\n    ax2.set_ylabel('X2')\n    fig.colorbar(contour, ax=ax2)\n\n    if x1_point is not None and x2_point is not None:\n        ax2.scatter(x1_point, x2_point, color='red', s=50)\n\n    plt.show()\n\n# Ejemplo de uso con la función de Rosenbrock\ndef rosenbrock(x1, x2, a=1, b=100):\n    return (a - x1)**2 + b * (x2 - x1**2)**2\n\nplot_function(rosenbrock, x1_range=(-2, 2), x2_range=(-1, 3), title=\"Rosenbrock Function\", x1_point=-1, x2_point=1)\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n\n\ndef plot_function(f, x1_range, x2_range, title=\"Function Plot\", x1_point=None, x2_point=None):\n    x1 = np.linspace(x1_range[0], x1_range[1], 400)\n    x2 = np.linspace(x2_range[0], x2_range[1], 400)\n    X1, X2 = np.meshgrid(x1, x2)\n    Z = f(X1, X2)\n\n    fig = plt.figure(figsize=(14, 6))\n\n    \n    # 3D plot\n    ax1 = fig.add_subplot(121, projection='3d')\n    if x1_point is not None and x2_point is not None:\n        z_point = f(x1_point, x2_point)\n        ax1.scatter(x1_point, x2_point, z_point, color='red', s=50, depthshade=False)  # Ajuste pequeño\n    ax1.plot_surface(X1, X2, Z, cmap='viridis', alpha=0.7)\n    ax1.set_title(f'3D Plot of {title}')\n    ax1.set_xlabel('X1')\n    ax1.set_ylabel('X2')\n    ax1.set_zlabel('Z')\n\n   \n\n    # Contour plot\n    ax2 = fig.add_subplot(122)\n    contour = ax2.contour(X1, X2, Z, cmap='viridis')\n    ax2.set_title(f'Contour Plot of {title}')\n    ax2.set_xlabel('X1')\n    ax2.set_ylabel('X2')\n    fig.colorbar(contour, ax=ax2)\n\n    if x1_point is not None and x2_point is not None:\n        ax2.scatter(x1_point, x2_point, color='red', s=50)\n\n    plt.show()\n\n# Ejemplo de uso con la función de Rosenbrock\ndef rosenbrock(x1, x2, a=1, b=100):\n    return (a - x1)**2 + b * (x2 - x1**2)**2\n\nplot_function(rosenbrock, x1_range=(-2, 2), x2_range=(-1, 3), title=\"Rosenbrock Function\", x1_point=-1, x2_point=1)\n\n\n\n\n\n\n\n\n\n\n\nCode\ndef plot_function(f, x1_range, x2_range, title=\"Function Plot\", x1_point=None, x2_point=None):\n    x1 = np.linspace(x1_range[0], x1_range[1], 400)\n    x2 = np.linspace(x2_range[0], x2_range[1], 400)\n    X1, X2 = np.meshgrid(x1, x2)\n    Z = f(X1, X2)\n\n    fig = plt.figure(figsize=(14, 6))\n\n    # 3D plot\n    ax1 = fig.add_subplot(121, projection='3d')\n    # Primero dibujamos la superficie\n    surface = ax1.plot_surface(X1, X2, Z, cmap='viridis', alpha=0.7)\n    \n    # Luego dibujamos el punto\n    if x1_point is not None and x2_point is not None:\n        z_point = f(x1_point, x2_point)\n        ax1.scatter(x1_point, x2_point, z_point, color='red', s=100, depthshade=False, linewidth=2, edgecolor='black')\n    \n    ax1.set_title(f'3D Plot of {title}')\n    ax1.set_xlabel('X1')\n    ax1.set_ylabel('X2')\n    ax1.set_zlabel('Z')\n\n\n\n\nCode\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nimport numpy as np\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n\ndef plot_function_3d(f, x1_range, x2_range, title=\"Function Plot\", x1_point=None, x2_point=None):\n    # Create the mesh grid\n    x1 = np.linspace(x1_range[0], x1_range[1], 100)\n    x2 = np.linspace(x2_range[0], x2_range[1], 100)\n    X1, X2 = np.meshgrid(x1, x2)\n    Z = f(X1, X2)\n    \n    # Create subplots\n    fig = make_subplots(\n        rows=1, cols=2,\n        specs=[[{'type': 'surface'}, {'type': 'contour'}]],\n        subplot_titles=('3D Surface Plot', 'Contour Plot')\n    )\n    \n    # Add surface plot\n    fig.add_trace(\n        go.Surface(x=X1, y=X2, z=Z, colorscale='viridis', opacity=0.8),\n        row=1, col=1\n    )\n    \n    # Add point if specified\n    if x1_point is not None and x2_point is not None:\n        z_point = f(x1_point, x2_point)\n        fig.add_trace(\n            go.Scatter3d(\n                x=[x1_point],\n                y=[x2_point],\n                z=[z_point],\n                mode='markers',\n                marker=dict(size=8, color='red'),\n                name='Point'\n            ),\n            row=1, col=1\n        )\n    \n    # Add contour plot\n    fig.add_trace(\n        go.Contour(\n            x=x1,\n            y=x2,\n            z=Z,\n            colorscale='viridis'\n        ),\n        row=1, col=2\n    )\n    \n    # Update layout\n    fig.update_layout(\n        title=title,\n        width=1200,\n        height=500,\n        scene=dict(\n            xaxis_title='X1',\n            yaxis_title='X2',\n            zaxis_title='Z'\n        )\n    )\n    \n    fig.show()\n\n# Test the function\ndef rosenbrock(x1, x2, a=1, b=100):\n    return (a - x1)**2 + b * (x2 - x1**2)**2\n\nplot_function_3d(rosenbrock, (-2, 2), (-1, 3), \"Rosenbrock Function\", x1_point=-1, x2_point=1)\n\nplot_function(rosenbrock, x1_range=(-5, 5), x2_range=(-5, 15), title=\"Rosenbrock Function\",x1_point=-1, x2_point=1)\n\n\n\n---------------------------------------------------------------------------\nModuleNotFoundError                       Traceback (most recent call last)\nCell In[64], line 2\n      1 import numpy as np\n----&gt; 2 import plotly.graph_objects as go\n      3 from plotly.subplots import make_subplots\n      5 def plot_function_3d(f, x1_range, x2_range, title=\"Function Plot\", x1_point=None, x2_point=None):\n      6     # Create the mesh grid\n\nModuleNotFoundError: No module named 'plotly'"
  }
]